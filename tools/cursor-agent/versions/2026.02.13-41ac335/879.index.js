try{!function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},t=(new e.Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="f93c9341-7a0b-412a-953d-e9acd5b77271",e._sentryDebugIdIdentifier="sentry-dbid-f93c9341-7a0b-412a-953d-e9acd5b77271")}()}catch(e){}!function(){try{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{}).SENTRY_RELEASE={id:"agent-cli@2026.02.13-41ac335"}}catch(e){}}(),exports.id=879,exports.ids=[879],exports.modules={"../agent-analytics/dist/commit-scoring/git-repo-utils.js":(e,t,n)=>{function i(e){const t=e.lastIndexOf("."),n=Math.max(e.lastIndexOf("/"),e.lastIndexOf("\\"));return-1===t||t<n?"":e.slice(t+1)}function a(e){if(!e)return;const t=e.replace("https///","https://").replace("http///","http://");if(t.startsWith("gitlab-remote://"))try{const e=new URL(t).searchParams.get("project");if(e)return e.includes("/")?e:void 0}catch(e){}const n=function(e){try{let t=e;return e.includes("@")&&!e.startsWith("http")&&(e.startsWith("ssh://")||(t=e.replace(/^([^@]+)@([^:]+):(.*)/,"ssh://$1@$2/$3"))),new URL(t)}catch(e){return null}}(t);if(!n)return;const i=n.hostname.toLowerCase(),a=n.pathname.split("/").filter((e=>e.length>0));if(a.length>0&&a[a.length-1].endsWith(".git")&&(a[a.length-1]=a[a.length-1].slice(0,-4)),"dev.azure.com"===i||"ssh.dev.azure.com"===i||i.endsWith(".visualstudio.com")){const e=[...a];"ssh.dev.azure.com"===i&&e.length>0&&"v3"===e[0].toLowerCase()&&e.shift();const t=e.filter((e=>"_git"!==e.toLowerCase()));return t.length>=1?t.join("/"):void 0}return i.includes("github")?a.length>=2?a.slice(0,2).join("/"):void 0:i.includes("gitlab")?a.length>=1?a.join("/"):void 0:(i.includes("bitbucket")||i.includes("stash"))&&a.length>=3&&"scm"===a[0].toLowerCase()?a.slice(1,3).join("/"):a.length>=2?a.slice(0,2).join("/"):void 0}n.d(t,{Z:()=>i,m:()=>a})},"../agent-analytics/dist/commit-scoring/index.js":(e,t,n)=>{function i(e,t){const n=[];let i=0,a=0,s=null;for(;i<e.length||a<t.length;){const o=e[i],r=t[a];if(o===r)s&&(n.push(s),s=null),i++,a++;else if(i>=e.length)s?s.modified.endLineNumberExclusive=a+2:s={original:{startLineNumber:i+1,endLineNumberExclusive:i+1},modified:{startLineNumber:a+1,endLineNumberExclusive:a+2}},a++;else if(a>=t.length)s?s.original.endLineNumberExclusive=i+2:s={original:{startLineNumber:i+1,endLineNumberExclusive:i+1},modified:{startLineNumber:a+1,endLineNumberExclusive:a+1}},i++;else{const n=e[i+1],c=t[a+1];n===c?(s?(s.original.endLineNumberExclusive=i+2,s.modified.endLineNumberExclusive=a+2):s={original:{startLineNumber:i+1,endLineNumberExclusive:i+2},modified:{startLineNumber:a+1,endLineNumberExclusive:a+2}},i++,a++):n===r?(s?s.original.endLineNumberExclusive=i+2:s={original:{startLineNumber:i+1,endLineNumberExclusive:i+2},modified:{startLineNumber:a+1,endLineNumberExclusive:a+1}},i++):c===o?(s?s.modified.endLineNumberExclusive=a+2:s={original:{startLineNumber:i+1,endLineNumberExclusive:i+1},modified:{startLineNumber:a+1,endLineNumberExclusive:a+2}},a++):(s?(s.original.endLineNumberExclusive=i+2,s.modified.endLineNumberExclusive=a+2):s={original:{startLineNumber:i+1,endLineNumberExclusive:i+2},modified:{startLineNumber:a+1,endLineNumberExclusive:a+2}},i++,a++)}}return s&&n.push(s),n}function a(e,t){let n=e;const i=t.startsWith(".")?t.toLowerCase():`.${t.toLowerCase()}`;return n=n.trim(),".js"!==i&&".ts"!==i&&".jsx"!==i&&".tsx"!==i||(n=n.replace(/\(\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\)\s*=>/g,"$1=>"),n=n.replace(/\$\{\s*([^}]+)\s*\}/g,"${$1}")),".py"===i&&(n=n.replace(/'''/g,'"'),n=n.replace(/"""/g,'"'),n=n.replace(/f"/g,'"'),n=n.replace(/f'/g,'"'),n=n.replace(/([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(?![=])/g,"$1=")),".rb"===i&&(n=n.replace(/:\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*=>/g,"$1:"),n=n.replace(/#\{\s*([^}]+)\s*\}/g,"#{$1}")),n=n.replace(/\s+/g,""),n=n.replace(/'/g,'"'),".js"!==i&&".ts"!==i&&".jsx"!==i&&".tsx"!==i||(n=n.replace(/`/g,'"')),n=n.replace(/;/g,""),n=n.replace(/,/g,""),n}n.d(t,{IA:()=>o.I,yY:()=>c,ld:()=>i,yF:()=>r,Zd:()=>h.Z,H2:()=>L,hA:()=>m,fS:()=>E}),new Set(["ls","cat","grep","pwd","echo","head","tail","less","more","wc","which","whereis","type","dir","cd","env","printenv","whoami","date","time","uptime","uname","df","du","ps","top","htop","history","alias","help","man","info","--help","--version"]);class s{static hash(e,t){let n,i,a;const s=3432918353,o=461845907;let r,c;n=3&e.length;const d=e.length-n;for(i=t,c=0;c<d;)r=255&e.charCodeAt(c)|(255&e.charCodeAt(++c))<<8|(255&e.charCodeAt(++c))<<16|(255&e.charCodeAt(++c))<<24,++c,r=((65535&r)*s+(((r>>>16)*s&65535)<<16)&4294967295)>>>0,r=r<<15|r>>>17,r=((65535&r)*o+(((r>>>16)*o&65535)<<16)&4294967295)>>>0,i^=r,i=i<<13|i>>>19,a=(5*(65535&i)+((5*(i>>>16)&65535)<<16)&4294967295)>>>0,i=27492+(65535&a)+((58964+(a>>>16)&65535)<<16)>>>0;return r=0,n>=3&&(r^=(255&e.charCodeAt(c+2))<<16),n>=2&&(r^=(255&e.charCodeAt(c+1))<<8),n>=1&&(r^=255&e.charCodeAt(c),r=((65535&r)*s+(((r>>>16)*s&65535)<<16)&4294967295)>>>0,r=r<<15|r>>>17,r=((65535&r)*o+(((r>>>16)*o&65535)<<16)&4294967295)>>>0,i^=r),i^=e.length,i^=i>>>16,i=(2246822507*(65535&i)+((2246822507*(i>>>16)&65535)<<16)&4294967295)>>>0,i^=i>>>13,i=(3266489909*(65535&i)+((3266489909*(i>>>16)&65535)<<16)&4294967295)>>>0,i^=i>>>16,(i>>>0).toString(16)}}var o=n("../agent-analytics/dist/commit-scoring/types.js");function r(e,t,n,i){const a=e.split("\n"),s=t.split("\n"),o=new Map;for(const e of i){const t=e.original.startLineNumber,i=e.original.endLineNumberExclusive,r=e.modified.startLineNumber,c=e.modified.endLineNumberExclusive,h=d(a,t,i),m=d(s,r,c);if(0!==h.length&&0!==m.length&&l(h,n)===l(m,n)){const e=u(r,c).join(",");for(let n=t;n<i;n++)o.set(String(n),e)}}return o}async function c(e,t,n,i,r,c,d){const l=t.split("\n"),u=n.split("\n"),h=new Map;for(const[t,n]of e.entries()){const e=parseInt(t,10);if(Number.isNaN(e)||e<1||e>l.length)continue;const o=l[e-1],d=c?a(o,r):o;if(!d.trim())continue;const u=`${i}:+${d}`,m=s.hash(u,0);h.set(m,{originalLineNum:e,newLinesStr:n})}const m=Array.from(h.keys());if(0===m.length)return 0;const f=await d.getAiGeneratedBatch(m),v=new Set,g=[];for(const[e,{newLinesStr:t}]of h.entries()){const n=f[e];if(!n)continue;if(n.source===o.I.TAB&&n.conversationId){console.warn(`[FormatDetection] Found TAB source with conversationId for hash ${e}. This may indicate a hash collision or data corruption. Skipping format propagation.`);continue}const d=t.split(",").map((e=>parseInt(e.trim(),10))).filter((e=>!Number.isNaN(e)&&e>=1&&e<=u.length));for(const e of d){if(v.has(e))continue;const t=u[e-1],d=c?a(t,r):t;if(!d.trim())continue;const l=`${i}:+${d}`,h=s.hash(l,0),m=Object.assign(Object.assign({},n),{fileExtension:r,timestamp:Date.now(),conversationId:n.source===o.I.TAB?void 0:n.conversationId});g.push({hash:h,metadata:m}),v.add(e)}}return g.length>0&&await d.storeHashes(g),g.length}function d(e,t,n){return e.slice(t-1,n-1)}function l(e,t){return e.map((e=>a(e,t))).filter((e=>e.length>0)).join("")}function u(e,t){const n=[];for(let i=e;i<t;i++)n.push(i);return n}var h=n("../agent-analytics/dist/commit-scoring/git-repo-utils.js");function m(e,t,n,i,r,c={}){const{normalizeLines:d=!0}=c,l=r.fileExtension||(0,h.Z)(e),u=[],m=Date.now();for(const c of i){for(let n=c.original.startLineNumber;n<c.original.endLineNumberExclusive;n++){const i=n-1;if(i<0||i>=t.length)continue;const c=t[i],h=d?a(c,l):c;if(!h.trim())continue;const f=`${e}:-${h}`,v=s.hash(f,0);u.push({hash:v,metadata:Object.assign(Object.assign({},r),{fileExtension:l,timestamp:m}),operationType:o.$.DELETION})}for(let t=c.modified.startLineNumber;t<c.modified.endLineNumberExclusive;t++){const i=t-1;if(i<0||i>=n.length)continue;const c=n[i],h=d?a(c,l):c;if(!h.trim())continue;const f=`${e}:+${h}`,v=s.hash(f,0);u.push({hash:v,metadata:Object.assign(Object.assign({},r),{fileExtension:l,timestamp:m}),operationType:o.$.ADDITION})}}return u}var f=function(e,t){var n={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.indexOf(i)<0&&(n[i]=e[i]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(i=Object.getOwnPropertySymbols(e);a<i.length;a++)t.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(e,i[a])&&(n[i[a]]=e[i[a]])}return n};const v=["+","-","\\ No newline at end of file"];function g(e,t,n={}){var i;const{normalizeLines:a=!0,isAiDeletedFile:r}=n,c=!e.to||"/dev/null"===e.to,d=c?e.from||"":e.to;if(!d)return{filePath:"",tabLinesAdded:0,tabLinesDeleted:0,composerLinesAdded:0,composerLinesDeleted:0,humanLinesAdded:0,humanLinesDeleted:0,blankLinesAdded:0,blankLinesDeleted:0,linesAdded:0,linesDeleted:0,hashes:[],changeId:void 0,aiLineRanges:new Map,isFullDeletion:!1};const l=d.replace(/\\/g,"/"),u=(0,h.Z)(l);if(c&&(null==r?void 0:r(l))){let t=0,n=0;for(const i of e.chunks)for(const e of i.changes)"del"===e.type&&(t++,""===e.content.slice(1).trim()&&n++);return{filePath:l,tabLinesAdded:0,tabLinesDeleted:0,composerLinesAdded:0,composerLinesDeleted:t,humanLinesAdded:0,humanLinesDeleted:0,blankLinesAdded:0,blankLinesDeleted:n,linesAdded:0,linesDeleted:t,hashes:[],changeId:void 0,aiLineRanges:new Map,isFullDeletion:!0}}let m=0,f=0,g=0,E=0,b=0,A=0,L=0,w=0,N=0,I=0;const y=[],C=new Map,S=[];for(const n of e.chunks)for(const e of n.changes){if("normal"===e.type)continue;const n=""===e.content.slice(1).trim();if(!n&&v.includes(e.content.trim()))continue;"add"===e.type?(N++,n&&L++):"del"===e.type&&(I++,n&&w++);const i=T(l,e.content,u,t,a);S.push({line:e,isBlank:n,aiGenerated:i?{hash:i.hash,metadata:i.metadata}:void 0})}for(let e=0;e<S.length;e++){const t=S[e],{line:n,isBlank:a,aiGenerated:s}=t;let r=s;if(a&&!r){let t,i;for(let i=e-1;i>=0;i--){const e=S[i];if(e.line.type===n.type&&!e.isBlank){t=e.aiGenerated;break}}for(let t=e+1;t<S.length;t++){const e=S[t];if(e.line.type===n.type&&!e.isBlank){i=e.aiGenerated;break}}t&&i&&(r=t)}if(r){if(s&&!a){const e="add"===n.type?o.$.ADDITION:o.$.DELETION;y.push({hash:r.hash,metadata:r.metadata,operationType:e})}const e=null!==(i=n.lineNumber)&&void 0!==i?i:n.ln;if("number"==typeof e&&("add"===n.type||"del"===n.type)){const t=r.metadata.source,i=t===o.I.COMPOSER||t===o.I.CLI?r.metadata.conversationId:r.metadata.requestId;p(C,t,n.type,e,i,r.metadata.requestId,r.metadata.model)}r.metadata.source===o.I.TAB?"add"===n.type?m++:f++:r.metadata.source===o.I.COMPOSER||r.metadata.source===o.I.CLI?"add"===n.type?g++:E++:r.metadata.source===o.I.HUMAN?"add"===n.type?b++:A++:r.metadata.source}}const R=y.length>0?function(e,t){const n=t.map((e=>`${e.metadata.source}:${e.hash}`)).sort();return s.hash(`${e}:${n.join(",")}`,0)}(l,y):void 0;return{filePath:l,tabLinesAdded:m,tabLinesDeleted:f,composerLinesAdded:g,composerLinesDeleted:E,humanLinesAdded:b,humanLinesDeleted:A,blankLinesAdded:L,blankLinesDeleted:w,linesAdded:N,linesDeleted:I,hashes:y,changeId:R,aiLineRanges:C,isFullDeletion:c}}async function E(e,t){const{gitOperations:n,repoRoot:i,commitHash:a,commitTimestamp:s}=t,o=f(t,["gitOperations","repoRoot","commitHash","commitTimestamp"]);if(!n)throw new Error("gitOperations is required for scoreAndAnnotateCommit");if(!n.getAiCodeHashes||!n.getTrackingStartTime)throw new Error("gitOperations must implement getAiCodeHashes and getTrackingStartTime");const r=await n.getTrackingStartTime(),c=await n.getAiCodeHashes(e,o,r,s);if(!(0!==Object.keys(c).length||o.isAiDeletedFile&&e.some((e=>(!e.to||"/dev/null"===e.to)&&o.isAiDeletedFile((e.from||"").replace(/\\/g,"/"))))))return null;const d=function(e,t,n={}){return function(e,t,n={}){let i=0,a=0,s=0,o=0,r=0,c=0,d=0,l=0,u=0,h=0;const m=[],f=[],v=new Map;for(const E of e.diff){const e=g(E,t,n);f.push(e),i+=e.tabLinesAdded,a+=e.tabLinesDeleted,s+=e.composerLinesAdded,o+=e.composerLinesDeleted,r+=e.humanLinesAdded,c+=e.humanLinesDeleted,d+=e.blankLinesAdded,l+=e.blankLinesDeleted,u+=e.linesAdded,h+=e.linesDeleted,e.changeId&&m.push(e.changeId),e.aiLineRanges.size>0&&v.set(e.filePath,e.aiLineRanges)}let E=0;for(const e of f)e.isFullDeletion&&0===e.tabLinesAdded+e.tabLinesDeleted+e.composerLinesAdded+e.composerLinesDeleted&&(E+=e.linesAdded+e.linesDeleted);const p=u+h-E;return{tabLinesAdded:i,tabLinesDeleted:a,composerLinesAdded:s,composerLinesDeleted:o,humanLinesAdded:r,humanLinesDeleted:c,blankLinesAdded:d,blankLinesDeleted:l,linesAdded:u,linesDeleted:h,changeIds:m,files:f,aiPercentage:p>0?((i+a+s+o)/p*100).toFixed(2):"0.00",aiLineRanges:v}}({hash:"",diff:e},t,n)}(e,(e=>c[e]),o);return Object.assign({},d)}function p(e,t,n,i,a,s,o){var r;const c=null!==(r=e.get(t))&&void 0!==r?r:{additions:[],deletions:[]};"add"===n?c.additions.push({lineNumber:i,conversationId:a,requestId:s,model:o}):c.deletions.push({lineNumber:i,conversationId:a,requestId:s,model:o}),e.set(t,c)}function T(e,t,n,i,a){const s=A(e,t,n,a);for(const e of s){const t=i(e);if(t)return{hash:e,metadata:t}}}function b(e,t){const n=`${e}:${t}`;return s.hash(n,0)}function A(e,t,n,i){const s=[];if(s.push(b(e,t)),i){const i=t.charAt(0),o=t.slice(1),r=a(o,n);if(r!==o){const t=i+r;s.push(b(e,t))}}return s}function L(e,t={}){const{normalizeLines:n=!0}=t,i=[];for(const t of e){const e=t.to||t.from||"";if(!e)continue;const a=(0,h.Z)(e);for(const s of t.chunks||[])for(const t of s.changes||[]){if("add"!==t.type&&"del"!==t.type)continue;if(!t.content)continue;const s=A(e,t.content,a,n);i.push(...s)}}return i}},"../agent-analytics/dist/commit-scoring/types.js":(e,t,n)=>{var i,a;n.d(t,{$:()=>a,I:()=>i}),function(e){e.TAB="tab",e.COMPOSER="composer",e.CLI="cli",e.HUMAN="human"}(i||(i={})),function(e){e.ADDITION="addition",e.DELETION="deletion"}(a||(a={}))},"../agent-analytics/dist/index.js":(e,t,n)=>{async function i(e,t,n={}){const{limit:i=10}=n,a=await e.getGitUser(t);if(a)return{user:a,commits:await e.getCommitsByAuthor(t,a,i)}}n.d(t,{Ou:()=>m,f_:()=>r,pt:()=>c,IG:()=>i,Mz:()=>s});var a=n("node:path");async function s(e,t,n){var i;const s=t.replace(/\\/g,"/"),o=null!==(i=null==n?void 0:n.replace(/\\/g,"/"))&&void 0!==i?i:s;try{const n=await e.getGitRoot((0,a.dirname)(t));if(n){const e=(0,a.relative)(n,t);if(e&&!e.startsWith(".."))return e.replace(/\\/g,"/")}}catch(e){}return o}var o=n("../agent-analytics/dist/commit-scoring/git-repo-utils.js");async function r(e,t){const n=new Set,i=[];for(const s of t)try{const t=await e.getGitRoot(s);if(t){const s=(0,a.normalize)(t);n.has(s)||(n.add(s),i.push(s));const o=await e.getSubmodules(t);if(o)for(const s of o){const o=(0,a.join)(t,s.relativePath),r=await e.getGitRoot(o);if(r){const e=(0,a.normalize)(r);n.has(e)||(n.add(e),i.push(e))}}}}catch(e){}return i}async function c(e,t){let n,i,a;try{[n,a]=await Promise.all([e.getCurrentBranch(t),e.getDefaultBranch(t)]);const s=await e.getUpstreamUrl(t);i=(0,o.m)(s)}catch(e){}return{branchName:n,repoName:i,primaryBranch:a,isPrimaryBranch:"string"==typeof n&&"string"==typeof a&&Boolean(n)&&Boolean(a)?n===a:void 0}}var d=n("../agent-analytics/dist/commit-scoring/types.js");class l{cache;maxSize;constructor(e){if(e<=0)throw new Error("LRU cache maxSize must be positive");this.cache=new Map,this.maxSize=e}get(e){if(!this.cache.has(e))return;const t=this.cache.get(e);return this.cache.delete(e),this.cache.set(e,t),t}set(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxSize){const e=this.cache.keys().next().value;void 0!==e&&this.cache.delete(e)}this.cache.set(e,t)}has(e){return this.cache.has(e)}delete(e){return this.cache.delete(e)}clear(){this.cache.clear()}get size(){return this.cache.size}entries(){return Array.from(this.cache.entries())}}const u=1048576,h=900;class m{db;dbPath;adapter;hashCache;scoredCommitsCache;trackingStartTimeCache;constructor(e,t,n){var i,a;if(!e)throw new Error("SqliteAdapter is required. This package has no SQLite dependencies - you must provide an adapter.");this.adapter=e,this.dbPath=t,this.hashCache=new l(null!==(i=null==n?void 0:n.hashCacheSize)&&void 0!==i?i:1e4),this.scoredCommitsCache=new l(null!==(a=null==n?void 0:n.scoredCommitsCacheSize)&&void 0!==a?a:500)}async initialize(){if(this.db)return;this.db=await this.adapter.openDatabase(this.dbPath),await this.db.run("\n      CREATE TABLE IF NOT EXISTS ai_code_hashes (\n        hash TEXT PRIMARY KEY,\n        source TEXT NOT NULL,\n        fileExtension TEXT,\n        fileName TEXT,\n        requestId TEXT,\n        conversationId TEXT,\n        timestamp INTEGER,\n        model TEXT,\n        createdAt INTEGER NOT NULL\n      )\n    ");try{await this.db.run("\n        ALTER TABLE ai_code_hashes ADD COLUMN model TEXT\n      ")}catch(e){}await this.db.run("\n      CREATE INDEX IF NOT EXISTS idx_ai_code_hashes_createdAt\n      ON ai_code_hashes(createdAt)\n    "),await this.db.run("\n      CREATE TABLE IF NOT EXISTS scored_commits (\n        commitHash TEXT NOT NULL,\n        branchName TEXT NOT NULL,\n        scoredAt INTEGER NOT NULL,\n        PRIMARY KEY (commitHash, branchName)\n      )\n    ");const e=["linesAdded INTEGER","linesDeleted INTEGER","tabLinesAdded INTEGER","tabLinesDeleted INTEGER","composerLinesAdded INTEGER","composerLinesDeleted INTEGER","humanLinesAdded INTEGER","humanLinesDeleted INTEGER","blankLinesAdded INTEGER","blankLinesDeleted INTEGER","commitMessage TEXT","commitDate TEXT","v1AiPercentage TEXT","v2AiPercentage TEXT"];for(const t of e)try{await this.db.run(`ALTER TABLE scored_commits ADD COLUMN ${t}`)}catch(e){}await this.db.run("\n      CREATE INDEX IF NOT EXISTS idx_scored_commits_scoredAt\n      ON scored_commits(scoredAt)\n    "),await this.db.run("\n      CREATE TABLE IF NOT EXISTS tracking_state (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL\n      )\n    "),await this.db.run("\n      CREATE TABLE IF NOT EXISTS conversation_summaries (\n        conversationId TEXT PRIMARY KEY,\n        title TEXT,\n        tldr TEXT,\n        overview TEXT,\n        summaryBullets TEXT,\n        model TEXT,\n        mode TEXT,\n        updatedAt INTEGER NOT NULL\n      )\n    "),await this.db.run("\n      CREATE INDEX IF NOT EXISTS idx_conversation_summaries_updatedAt\n      ON conversation_summaries(updatedAt)\n    "),await this.db.run("\n      CREATE TABLE IF NOT EXISTS tracked_file_content (\n        gitPath TEXT PRIMARY KEY,\n        content TEXT NOT NULL,\n        conversationId TEXT,\n        model TEXT,\n        fileExtension TEXT,\n        createdAt INTEGER NOT NULL\n      )\n    "),await this.db.run("\n      CREATE INDEX IF NOT EXISTS idx_tracked_file_content_createdAt\n      ON tracked_file_content(createdAt)\n    "),await this.db.run("\n      CREATE TABLE IF NOT EXISTS ai_deleted_files (\n        gitPath TEXT NOT NULL,\n        composerId TEXT,\n        conversationId TEXT,\n        model TEXT,\n        deletedAt INTEGER NOT NULL,\n        PRIMARY KEY (gitPath, deletedAt)\n      )\n    "),await this.db.run("\n      CREATE INDEX IF NOT EXISTS idx_ai_deleted_files_deletedAt\n      ON ai_deleted_files(deletedAt)\n    ");const t=Date.now()-6048e5;await this.db.run("DELETE FROM tracked_file_content WHERE createdAt < ?",[t]),await this.db.run("DELETE FROM ai_deleted_files WHERE deletedAt < ?",[t])}async storeHashes(e){var t,n,i,a,s,o;if(this.db||await this.initialize(),0===e.length)return;const r=Date.now(),c=this.db;await c.run("BEGIN TRANSACTION");try{for(const{hash:l,metadata:u}of e){let e=null!==(t=u.conversationId)&&void 0!==t?t:null;u.source===d.I.TAB&&e&&(console.warn(`[AiCodeTracking] Attempted to store TAB source with conversationId for hash ${l}. Clearing conversationId to prevent data corruption.`),e=null),await c.run("\n      INSERT OR REPLACE INTO ai_code_hashes\n      (hash, source, fileExtension, fileName, requestId, conversationId, timestamp, model, createdAt)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    ",[l,u.source,null!==(n=u.fileExtension)&&void 0!==n?n:null,null!==(i=u.fileName)&&void 0!==i?i:null,null!==(a=u.requestId)&&void 0!==a?a:null,e,null!==(s=u.timestamp)&&void 0!==s?s:null,null!==(o=u.model)&&void 0!==o?o:null,r])}await c.run("COMMIT");for(const{hash:t,metadata:n}of e){const e=n.source===d.I.TAB&&n.conversationId?Object.assign(Object.assign({},n),{conversationId:void 0}):n;this.hashCache.set(t,e)}}catch(e){throw await c.run("ROLLBACK"),e}}async storeHash(e,t){return this.storeHashes([{hash:e,metadata:t}])}async recordAiDeletedFile(e,t){var n,i,a;this.db||await this.initialize();const s=Date.now();await this.db.run("INSERT OR IGNORE INTO ai_deleted_files (gitPath, composerId, conversationId, model, deletedAt) VALUES (?, ?, ?, ?, ?)",[e,null!==(n=null==t?void 0:t.composerId)&&void 0!==n?n:null,null!==(i=null==t?void 0:t.conversationId)&&void 0!==i?i:null,null!==(a=null==t?void 0:t.model)&&void 0!==a?a:null,s])}async getAiDeletedFiles(e,t){if(!this.db||0===e.length)return new Set;const n=e.map((()=>"?")).join(","),i=[...e];let a=`SELECT DISTINCT gitPath FROM ai_deleted_files WHERE gitPath IN (${n})`;void 0!==t&&(a+=" AND deletedAt <= ?",i.push(t));const s=await this.db.all(a,i);return new Set(s.map((e=>e.gitPath)))}async getHashes(e,t){var n,i,a,s,o,r;if(this.db||await this.initialize(),0===e.length)return{};const c={},l=[],u=void 0===(null==t?void 0:t.minCreatedAt)&&void 0===(null==t?void 0:t.maxCreatedAt);if(u)for(const t of e){const e=this.hashCache.get(t);void 0!==e?null!==e&&(c[t]=e):l.push(t)}else l.push(...e);if(l.length>0){const e=this.db,m=[],f=void 0!==(null==t?void 0:t.minCreatedAt),v=void 0!==(null==t?void 0:t.maxCreatedAt),g=h-((f?1:0)+(v?1:0));for(let u=0;u<l.length;u+=g){const h=l.slice(u,u+g);let E=`SELECT * FROM ai_code_hashes WHERE hash IN (${h.map((()=>"?")).join(",")})`;const p=[...h];f&&(E+=" AND createdAt >= ?",p.push(t.minCreatedAt)),v&&(E+=" AND createdAt <= ?",p.push(t.maxCreatedAt)),E+=" ORDER BY source != 'human' DESC, source = 'composer' DESC, model IS NULL, createdAt DESC";const T=await e.all(E,p),b=new Set,A=new Map;for(const e of T){if(A.has(e.hash)&&A.get(e.hash)!==e.source&&console.warn(`[AiCodeTracking] Hash collision detected for hash ${e.hash}: found both ${A.get(e.hash)} and ${e.source} sources. Preferring AI sources over HUMAN, then COMPOSER over TAB.`),b.has(e.hash))continue;A.set(e.hash,e.source);let t=null!==(n=e.conversationId)&&void 0!==n?n:void 0;e.source===d.I.TAB&&t&&(console.warn(`[AiCodeTracking] Found TAB source with conversationId for hash ${e.hash}. This may indicate a hash collision or data corruption. Clearing conversationId.`),t=void 0);const l={source:e.source,fileExtension:null!==(i=e.fileExtension)&&void 0!==i?i:void 0,fileName:null!==(a=e.fileName)&&void 0!==a?a:void 0,requestId:null!==(s=e.requestId)&&void 0!==s?s:void 0,conversationId:t,timestamp:null!==(o=e.timestamp)&&void 0!==o?o:void 0,model:null!==(r=e.model)&&void 0!==r?r:void 0};c[e.hash]=l,m.push(e.hash),b.add(e.hash),this.hashCache.set(e.hash,l)}}if(u)for(const e of l)m.includes(e)||this.hashCache.set(e,null)}return c}async getHash(e){return(await this.getHashes([e]))[e]}async hasHashes(e){if(this.db||await this.initialize(),0===e.length)return[];const t=this.db,n=[];for(let i=0;i<e.length;i+=h){const a=e.slice(i,i+h),s=a.map((()=>"?")).join(","),o=await t.all(`SELECT hash FROM ai_code_hashes WHERE hash IN (${s})`,a);n.push(...o.map((e=>e.hash)))}return n}async hasHash(e){return(await this.hasHashes([e])).includes(e)}async markCommitsScored(e){var t,n,i,a,s,o,r,c,d,l,u,h,m,f;if(this.db||await this.initialize(),0===e.length)return;const v=Date.now(),g=this.db;await g.run("BEGIN TRANSACTION");try{for(const{commitHash:E,branchName:p,scoreData:T}of e)await g.run("\n      INSERT OR REPLACE INTO scored_commits (\n        commitHash, branchName, scoredAt,\n        linesAdded, linesDeleted,\n        tabLinesAdded, tabLinesDeleted,\n        composerLinesAdded, composerLinesDeleted,\n        humanLinesAdded, humanLinesDeleted,\n        blankLinesAdded, blankLinesDeleted,\n        commitMessage, commitDate,\n        v1AiPercentage, v2AiPercentage\n      )\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    ",[E,p,v,null!==(t=null==T?void 0:T.linesAdded)&&void 0!==t?t:null,null!==(n=null==T?void 0:T.linesDeleted)&&void 0!==n?n:null,null!==(i=null==T?void 0:T.tabLinesAdded)&&void 0!==i?i:null,null!==(a=null==T?void 0:T.tabLinesDeleted)&&void 0!==a?a:null,null!==(s=null==T?void 0:T.composerLinesAdded)&&void 0!==s?s:null,null!==(o=null==T?void 0:T.composerLinesDeleted)&&void 0!==o?o:null,null!==(r=null==T?void 0:T.humanLinesAdded)&&void 0!==r?r:null,null!==(c=null==T?void 0:T.humanLinesDeleted)&&void 0!==c?c:null,null!==(d=null==T?void 0:T.blankLinesAdded)&&void 0!==d?d:null,null!==(l=null==T?void 0:T.blankLinesDeleted)&&void 0!==l?l:null,null!==(u=null==T?void 0:T.commitMessage)&&void 0!==u?u:null,null!==(h=null==T?void 0:T.commitDate)&&void 0!==h?h:null,null!==(m=null==T?void 0:T.v1AiPercentage)&&void 0!==m?m:null,null!==(f=null==T?void 0:T.v2AiPercentage)&&void 0!==f?f:null]);await g.run("COMMIT");for(const{commitHash:t,branchName:n}of e)this.scoredCommitsCache.set(`${t}:${n}`,!0)}catch(e){throw await g.run("ROLLBACK"),e}}async markCommitScored(e,t,n){return this.markCommitsScored([{commitHash:e,branchName:t,scoreData:n}])}async areCommitsScored(e){if(this.db||await this.initialize(),0===e.length)return[];const t=[],n=[];for(const{commitHash:i,branchName:a}of e){const e=`${i}:${a}`;this.scoredCommitsCache.has(e)?this.scoredCommitsCache.get(e)&&t.push(e):n.push({commitHash:i,branchName:a})}if(n.length>0){const e=this.db,i=new Set,a=Math.floor(450);for(let s=0;s<n.length;s+=a){const o=n.slice(s,s+a),r=o.map((()=>"(commitHash = ? AND branchName = ?)")).join(" OR "),c=o.flatMap((e=>[e.commitHash,e.branchName])),d=await e.all(`SELECT commitHash, branchName FROM scored_commits WHERE ${r}`,c);for(const e of d){const n=`${e.commitHash}:${e.branchName}`;t.push(n),i.add(n),this.scoredCommitsCache.set(n,!0)}}for(const{commitHash:e,branchName:t}of n){const n=`${e}:${t}`;i.has(n)||this.scoredCommitsCache.set(n,!1)}}return t}async isCommitScored(e,t){return(await this.areCommitsScored([{commitHash:e,branchName:t}])).includes(`${e}:${t}`)}async getTrackingStartTime(){if(void 0!==this.trackingStartTimeCache)return this.trackingStartTimeCache;this.db||await this.initialize();const e=this.db,t=await e.get("SELECT value FROM tracking_state WHERE key = ?",["trackingStartTime"]);if(t)try{const e=JSON.parse(t.value);return"number"==typeof e.timestamp?(this.trackingStartTimeCache=e.timestamp,e.timestamp):void 0}catch(e){return}}async setTrackingStartTime(e){this.db||await this.initialize();const t=this.db;await t.run("INSERT OR REPLACE INTO tracking_state (key, value) VALUES (?, ?)",["trackingStartTime",JSON.stringify({timestamp:e})]),this.trackingStartTimeCache=e}async deleteHashesBefore(e){var t;this.db||await this.initialize();const n=this.db,i=await n.get("SELECT COUNT(*) as count FROM ai_code_hashes WHERE createdAt < ?",[e]),a=null!==(t=null==i?void 0:i.count)&&void 0!==t?t:0;return a>0&&(await n.run("DELETE FROM ai_code_hashes WHERE createdAt < ?",[e]),this.hashCache.clear()),a}async getLastScoredCommitTime(){var e;this.db||await this.initialize();const t=this.db,n=await t.get("SELECT MAX(scoredAt) as maxScoredAt FROM scored_commits");return null!==(e=null==n?void 0:n.maxScoredAt)&&void 0!==e?e:void 0}async getStats(){var e,t,n,i;this.db||await this.initialize();const a=this.db,s=await a.get("SELECT COUNT(*) as count, MIN(createdAt) as oldest, MAX(createdAt) as newest FROM ai_code_hashes"),o=await a.get("SELECT COUNT(*) as count FROM scored_commits");return{hashCount:null!==(e=null==s?void 0:s.count)&&void 0!==e?e:0,scoredCommitCount:null!==(t=null==o?void 0:o.count)&&void 0!==t?t:0,oldestHashCreatedAt:null!==(n=null==s?void 0:s.oldest)&&void 0!==n?n:void 0,newestHashCreatedAt:null!==(i=null==s?void 0:s.newest)&&void 0!==i?i:void 0}}clearCaches(){this.hashCache.clear(),this.scoredCommitsCache.clear(),this.trackingStartTimeCache=void 0}getCacheStats(){return{hashCacheSize:this.hashCache.size,scoredCommitsCacheSize:this.scoredCommitsCache.size,trackingStartTimeCached:void 0!==this.trackingStartTimeCache}}async storeConversationSummary(e){var t,n,i,a,s,o,r;this.db||await this.initialize();const c=null!==(t=e.updatedAt)&&void 0!==t?t:Date.now(),d=this.db;await d.run("INSERT OR REPLACE INTO conversation_summaries\n       (conversationId, title, tldr, overview, summaryBullets, model, mode, updatedAt)\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?)",[e.conversationId,null!==(n=e.title)&&void 0!==n?n:null,null!==(i=e.tldr)&&void 0!==i?i:null,null!==(a=e.overview)&&void 0!==a?a:null,JSON.stringify(null!==(s=e.summaryBullets)&&void 0!==s?s:[]),null!==(o=e.model)&&void 0!==o?o:null,null!==(r=e.mode)&&void 0!==r?r:null,c])}async storeConversationSummaries(e){var t,n,i,a,s,o,r;if(this.db||await this.initialize(),0===e.length)return;const c=Date.now(),d=this.db;await d.run("BEGIN TRANSACTION");try{for(const l of e){const e=null!==(t=l.updatedAt)&&void 0!==t?t:c;await d.run("INSERT OR REPLACE INTO conversation_summaries\n           (conversationId, title, tldr, overview, summaryBullets, model, mode, updatedAt)\n           VALUES (?, ?, ?, ?, ?, ?, ?, ?)",[l.conversationId,null!==(n=l.title)&&void 0!==n?n:null,null!==(i=l.tldr)&&void 0!==i?i:null,null!==(a=l.overview)&&void 0!==a?a:null,JSON.stringify(null!==(s=l.summaryBullets)&&void 0!==s?s:[]),null!==(o=l.model)&&void 0!==o?o:null,null!==(r=l.mode)&&void 0!==r?r:null,e])}await d.run("COMMIT")}catch(e){throw await d.run("ROLLBACK"),e}}async getConversationSummaryTimestamps(e){if(this.db||await this.initialize(),0===e.length)return{};const t=this.db,n={};for(let i=0;i<e.length;i+=h){const a=e.slice(i,i+h),s=a.map((()=>"?")).join(","),o=await t.all(`SELECT conversationId, updatedAt FROM conversation_summaries WHERE conversationId IN (${s})`,a);for(const e of o)n[e.conversationId]=e.updatedAt}return n}async getConversationSummaries(e){if(this.db||await this.initialize(),0===e.length)return{};const t=this.db,n={};for(let i=0;i<e.length;i+=h){const a=e.slice(i,i+h),s=a.map((()=>"?")).join(","),o=await t.all(`SELECT * FROM conversation_summaries WHERE conversationId IN (${s})`,a);for(const e of o){let t=[];if(e.summaryBullets)try{const n=JSON.parse(e.summaryBullets);t=Array.isArray(n)?n:[]}catch(e){t=[]}n[e.conversationId]={conversationId:e.conversationId,title:e.title,tldr:e.tldr,overview:e.overview,summaryBullets:t,model:e.model,mode:e.mode,updatedAt:e.updatedAt}}}return n}async getConversationSummary(e){return(await this.getConversationSummaries([e]))[e]}async storeTrackedFileContent(e,t,n){var i,a,s;if(this.db||await this.initialize(),t.length>u)return;const o=this.db,r=Date.now();await o.run("INSERT OR REPLACE INTO tracked_file_content\n       (gitPath, content, conversationId, model, fileExtension, createdAt)\n       VALUES (?, ?, ?, ?, ?, ?)",[e,t,null!==(i=n.conversationId)&&void 0!==i?i:null,null!==(a=n.model)&&void 0!==a?a:null,null!==(s=n.fileExtension)&&void 0!==s?s:null,r])}async storeTrackedFileContents(e){var t,n,i;this.db||await this.initialize();const a=e.filter((e=>e.content.length<=u));if(0===a.length)return;const s=this.db,o=Date.now();await s.run("BEGIN TRANSACTION");try{for(const{gitPath:e,content:r,metadata:c}of a)await s.run("INSERT OR REPLACE INTO tracked_file_content\n           (gitPath, content, conversationId, model, fileExtension, createdAt)\n           VALUES (?, ?, ?, ?, ?, ?)",[e,r,null!==(t=c.conversationId)&&void 0!==t?t:null,null!==(n=c.model)&&void 0!==n?n:null,null!==(i=c.fileExtension)&&void 0!==i?i:null,o]);await s.run("COMMIT")}catch(e){throw await s.run("ROLLBACK"),e}}async getTrackedFileContents(e){if(this.db||await this.initialize(),0===e.length)return{};const t=this.db,n={};for(let i=0;i<e.length;i+=h){const a=e.slice(i,i+h),s=a.map((()=>"?")).join(","),o=await t.all(`SELECT * FROM tracked_file_content WHERE gitPath IN (${s})`,a);for(const e of o)n[e.gitPath]={gitPath:e.gitPath,content:e.content,conversationId:e.conversationId,model:e.model,fileExtension:e.fileExtension,createdAt:e.createdAt}}return n}async getTrackedFileContent(e){return(await this.getTrackedFileContents([e]))[e]}async deleteTrackedFileContents(e){if(this.db||await this.initialize(),0===e.length)return;const t=this.db;for(let n=0;n<e.length;n+=h){const i=e.slice(n,n+h),a=i.map((()=>"?")).join(",");await t.run(`DELETE FROM tracked_file_content WHERE gitPath IN (${a})`,i)}}async deleteTrackedFileContentBefore(e){var t;this.db||await this.initialize();const n=this.db,i=await n.get("SELECT COUNT(*) as count FROM tracked_file_content WHERE createdAt < ?",[e]),a=null!==(t=null==i?void 0:i.count)&&void 0!==t?t:0;return a>0&&await n.run("DELETE FROM tracked_file_content WHERE createdAt < ?",[e]),a}async getTrackedFilePathsForConversation(e){this.db||await this.initialize();const t=this.db;return(await t.all("SELECT gitPath FROM tracked_file_content WHERE conversationId = ?",[e])).map((e=>e.gitPath))}async close(){this.clearCaches(),this.db&&(await this.db.close(),this.db=void 0)}}},"../agent-analytics/dist/node.js":(e,t,n)=>{n.d(t,{Z:()=>s});var i=n("node:child_process");const a=(0,n("node:util").promisify)(i.execFile);class s{async executeGitCommand(e,t){try{const{stdout:n}=await a("git",t,{cwd:e,maxBuffer:10485760});return n.trim()}catch(e){const n=e;if(n.stdout)return n.stdout.trim();const i=`git ${t.map((e=>JSON.stringify(e))).join(" ")}`;throw new Error(`Git command failed: ${i}\n${n.stderr||String(e)}`)}}async getGitRoot(e){try{return(await this.executeGitCommand(e,["rev-parse","--show-toplevel"])).trim()||void 0}catch(e){return}}async getRemotes(e){try{return(await this.executeGitCommand(e,["remote"])).split("\n").map((e=>e.trim())).filter((e=>e.length>0))}catch(e){return[]}}async getGitUser(e){try{return(await this.executeGitCommand(e,["config","user.email"])).trim()||void 0}catch(e){return}}async getCommitsByAuthor(e,t,n){try{return(await this.executeGitCommand(e,["log",`--author=${t}`,"--format=%H","-n",String(n)])).split("\n").map((e=>e.trim())).filter((e=>e.length>0))}catch(e){return[]}}async getRecentCommits(e,t,n){try{const i=["log","--format=%H%x00%s","-n",String(t)];return n&&i.push(`--author=${n}`),(await this.executeGitCommand(e,i)).split("\n").map((e=>e.trim())).filter((e=>e.length>0)).map((e=>{const[t,...n]=e.split("\0");return{hash:t,message:n.join("\0")}})).filter((e=>e.hash.length>0))}catch(e){return[]}}async getCurrentBranch(e){try{const t=(await this.executeGitCommand(e,["rev-parse","--abbrev-ref","HEAD"])).trim();return t&&"HEAD"!==t?t:void 0}catch(e){return}}async getDefaultBranch(e){try{return(await this.executeGitCommand(e,["symbolic-ref","refs/remotes/origin/HEAD","--short"])).trim().replace(/^origin\//,"")||void 0}catch(t){try{return await this.executeGitCommand(e,["rev-parse","--verify","refs/heads/main"]),"main"}catch(t){try{return await this.executeGitCommand(e,["rev-parse","--verify","refs/heads/master"]),"master"}catch(e){return}}}}async getUpstreamUrl(e){try{return(await this.executeGitCommand(e,["remote","get-url","origin"])).trim()||void 0}catch(e){return}}async getSubmodules(e){try{const t=await this.executeGitCommand(e,["config","--file",".gitmodules","--get-regexp","path"]);if(!t.trim())return;const n=t.split("\n").map((e=>{const t=e.match(/^submodule\.(?:.+)\.path\s+(.+)$/);return t?{relativePath:t[1].trim()}:null})).filter((e=>null!==e));return n.length>0?n:void 0}catch(e){return}}async commitExists(e,t){try{return await this.executeGitCommand(e,["cat-file","-e",`${t}^{commit}`]),!0}catch(e){return!1}}async hashObject(e,t){return new Promise(((n,a)=>{const s=(0,i.spawn)("git",["-c","gc.auto=0","hash-object","-w","--stdin"],{cwd:t,shell:!1});let o="",r="";s.stdout.on("data",(e=>{o+=e.toString()})),s.stderr.on("data",(e=>{r+=e.toString()})),s.on("error",(e=>{a(new Error(`Git hash-object failed: ${e.message}`))})),s.on("close",(e=>{0===e?n(o.trim()):a(new Error(`Git hash-object failed (exit code ${e}): ${r}`))})),s.stdin.write(e),s.stdin.end()}))}async catBlob(e,t){return this.executeGitCommand(t,["cat-file","blob",e])}}},"./src/cursor-blame/format-lineage-callbacks.ts":(e,t,n)=>{n.d(t,{L:()=>a});var i=function(e,t,n,i){return new(n||(n=Promise))((function(a,s){function o(e){try{c(i.next(e))}catch(e){s(e)}}function r(e){try{c(i.throw(e))}catch(e){s(e)}}function c(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,r)}c((i=i.apply(e,t||[])).next())}))};function a(e){return{getAiGeneratedBatch:t=>i(this,void 0,void 0,(function*(){const n=yield e.getHashes(t),i={};for(const[e,t]of Object.entries(n))i[e]={source:t.source,fileExtension:t.fileExtension,fileName:t.fileName,requestId:t.requestId,conversationId:t.conversationId,model:t.model,timestamp:t.timestamp};return i})),storeHashes:t=>i(this,void 0,void 0,(function*(){yield e.storeHashes(t.map((({hash:e,metadata:t})=>({hash:e,metadata:{source:t.source,fileExtension:t.fileExtension,fileName:t.fileName,requestId:t.requestId,conversationId:t.conversationId,model:t.model,timestamp:t.timestamp}}))))}))}}},"./src/cursor-blame/sqlite-adapter.ts":(e,t,n)=>{n.d(t,{$:()=>c});var i=n("node:fs"),a=n("node:path"),s=n("../../node_modules/.pnpm/sqlite3@5.1.7_patch_hash=aee4b045019cd42c3fc35610736c4496fa74db4d4a28d55c814724e29047da6a/node_modules/sqlite3/lib/sqlite3.js"),o=n.n(s),r=function(e,t,n,i){return new(n||(n=Promise))((function(a,s){function o(e){try{c(i.next(e))}catch(e){s(e)}}function r(e){try{c(i.throw(e))}catch(e){s(e)}}function c(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,r)}c((i=i.apply(e,t||[])).next())}))};function c(){return{openDatabase(e){return r(this,void 0,void 0,(function*(){const t=(0,a.dirname)(e);(0,i.existsSync)(t)||(0,i.mkdirSync)(t,{recursive:!0});const n=new(o().Database)(e);return{run(e,t){return r(this,void 0,void 0,(function*(){return new Promise(((i,a)=>{n.run(e,...null!=t?t:[],(e=>{e?a(e):i()}))}))}))},get(e,t){return r(this,void 0,void 0,(function*(){return new Promise(((i,a)=>{n.get(e,...null!=t?t:[],((e,t)=>{e?a(e):i(t)}))}))}))},all(e,t){return r(this,void 0,void 0,(function*(){return new Promise(((i,a)=>{n.all(e,...null!=t?t:[],((e,t)=>{e?a(e):i(null!=t?t:[])}))}))}))},close(){return r(this,void 0,void 0,(function*(){return new Promise(((e,t)=>{n.close((n=>{n?t(n):e()}))}))}))}}}))},closeDatabase(){return r(this,void 0,void 0,(function*(){}))}}}}};