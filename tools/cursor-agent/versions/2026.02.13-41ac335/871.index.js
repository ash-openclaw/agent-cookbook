try{!function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="dead95f9-1ab6-48cf-8469-b5fde674f2fc",e._sentryDebugIdIdentifier="sentry-dbid-dead95f9-1ab6-48cf-8469-b5fde674f2fc")}()}catch(e){}!function(){try{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{}).SENTRY_RELEASE={id:"agent-cli@2026.02.13-41ac335"}}catch(e){}}(),exports.id=871,exports.ids=[871],exports.modules={"./src/commands/shell-integration.ts":(e,n,t)=>{t.r(n),t.d(n,{handleShellIntegration:()=>a});const o='\nexport PATH="$HOME/.local/bin:$PATH"\n\nif [[ -z "$CURSOR_RECORD_SESSION" ]]; then\n  export CURSOR_RECORD_SESSION=1\n\n  exec ~/.local/bin/agent record\nfi\n\nif [[ "$VSCODE_PROFILE_INITIALIZED" = "1" ]] && command -v cursor >/dev/null 2>&1; then\n  source $(cursor --locate-shell-integration-path zsh)\nfi\n\n# Only execute cursor agent integration if we\'re in a TTY\nif [[ -t 0 ]]; then\n\n# Cursor Agent Terminal Capture Hooks using custom OSC 9999\n# These hooks send custom OSC sequences that won\'t conflict with other tools\n\n# Function to send custom OSC sequence\n_cursor_agent_osc() {\n  printf "\\\\033]9999;%s\\\\007" "$1"\n}\n\n# Hook: Before executing a command\n_cursor_agent_preexec() {\n  # Send the full command line\n  _cursor_agent_osc "preexec;$1"\n}\n\n# Hook: After command execution, before prompt\n_cursor_agent_precmd() {\n  local last_exit_code=$?\n  # Send exit code first\n  _cursor_agent_osc "precmd;$last_exit_code"\n  # Then send prompt signal\n  _cursor_agent_osc "prompt"\n}\n\n# Register hooks\nautoload -Uz add-zsh-hook\nadd-zsh-hook preexec _cursor_agent_preexec\nadd-zsh-hook precmd _cursor_agent_precmd\n\n# Create a new chat session at the start of each shell session\nif [[ -z "$CURSOR_AGENT_CHAT_ID" ]]; then\n  export CURSOR_AGENT_CHAT_ID=$(command agent create-chat)\nfi\n\n# Agent alias for quick access to Cursor Agent with resume\nagent() {\n  AGENT_CLI_LOAD_HISTORY=false AGENT_CLI_HIDE_HEADER=true AGENT_CLI_HIDE_BANNER=true command agent --resume $CURSOR_AGENT_CHAT_ID "$@" <"$TTY" >"$TTY" 2>&1\n}\n\n\nplease-fix() {\n  if [[ ! -f "$CURSOR_AGENT_COMPLETED_PATH" ]]; then\n    echo "Error: No command history available, did you run a command?"\n    return 1\n  fi\n  local completed\n  completed=$(<$CURSOR_AGENT_COMPLETED_PATH)\n  local command exit_code output\n  command=$(head -n 1 $CURSOR_AGENT_COMPLETED_PATH)\n  exit_code=$(tail -n 1 $CURSOR_AGENT_COMPLETED_PATH)\n  # Get all lines except first and last as output\n  output=$(sed \'1d;$d\' $CURSOR_AGENT_COMPLETED_PATH)\n\n\tprint ""\n\n  # Output is wrapped in triple backticks for formatting\n  AGENT_CLI_LOAD_HISTORY=false AGENT_CLI_HIDE_PROMPT_BAR=true AGENT_CLI_EXIT_ON_COMPLETION=true AGENT_CLI_HIDE_USER_MESSAGES=true AGENT_CLI_HIDE_HEADER=true AGENT_CLI_HIDE_BANNER=true command agent --resume $CURSOR_AGENT_CHAT_ID --model auto "$(printf "I just ran the command: \\"%s\\", which exited with code %s. The output was:\\n\\n%s\\n\\nPlease help me fix it." "$command" "$exit_code" "$output")"\n}\n\n# Track if last command failed for please-fix suggestion\n_last_command_failed=0\n_command_was_executed=0\n\n# Hook to track command failures (combined with cursor agent hook)\n_cursor_fix_precmd() {\n  local last_exit_code=$?\n  if [[ $last_exit_code -ne 0 && -n "$CURSOR_AGENT_COMPLETED_PATH" && $_command_was_executed -eq 1 ]]; then\n    _last_command_failed=1\n    echo "\\x1b[90mðŸ’¡ Command failed with exit code $last_exit_code. Press Enter to fix.\\x1b[0m"\n  else\n    _last_command_failed=0\n  fi\n  _command_was_executed=0\n}\n\n# Hook to handle empty commands\n_cursor_fix_preexec() {\n  _last_command_failed=0\n  _command_was_executed=1\n}\n\n# Register please-fix hooks\nautoload -Uz add-zsh-hook\nadd-zsh-hook precmd _cursor_fix_precmd\nadd-zsh-hook preexec _cursor_fix_preexec\n\n## ---- Agent command streaming mode (Cursor Agent) ----\n\n# Preserve the original Enter handler\nzle -A accept-line .orig-accept-line\n\n# Mode: 0 = normal zsh, 1 = send buffer as prompt to Cursor Agent\nzsh_agent_mode=0\n\ntoggle-agent-mode() {\n  (( zsh_agent_mode ^= 1 ))\n  zle -M "Agent mode: $([ $zsh_agent_mode -eq 1 ] && echo on || echo off)"\n}\nzle -N toggle-agent-mode\n\n# Tab wrapper: at the beginning of the current line, toggle; otherwise perform normal completion\ntab-toggle-or-complete() {\n  # Beginning-of-line if nothing to the left or previous char is a newline (supports multiline buffers)\n  if [[ -z $LBUFFER || ${LBUFFER[-1]} == $\'\\n\' ]]; then\n    toggle-agent-mode\n  else\n    zle expand-or-complete\n  fi\n}\nzle -N tab-toggle-or-complete\n# Bind only in insert keymaps to avoid interfering with menu selection keymap\nbindkey -M emacs \'^I\' tab-toggle-or-complete\nbindkey -M viins \'^I\' tab-toggle-or-complete\n\n# Combined Enter dispatcher: handles please-fix, agent mode, and normal accept-line\nplease-fix-or-accept-line() {\n  # First check if we should handle please-fix on empty input\n  if [[ -z "$BUFFER" && $_last_command_failed -eq 1 ]]; then\n    BUFFER="please-fix"\n    _last_command_failed=0\n    zle .orig-accept-line\n    return\n  fi\n\n  # Then check if we\'re in agent mode\n  if (( zsh_agent_mode )); then\n    local prompt_text\n    prompt_text="$BUFFER"\n    if [[ -z $prompt_text ]]; then\n      zle .orig-accept-line\n      return\n    fi\n\n    # Keep original input in history\n    print -s -- "$prompt_text"\n\n    # Clear editing line and leave ZLE display before streaming\n    zle -I\n\n    print ""\n\n    # Ensure we start on a fresh line, stream directly to the TTY so it persists\n    { AGENT_CLI_LOAD_HISTORY=false AGENT_CLI_HIDE_PROMPT_BAR=true AGENT_CLI_EXIT_ON_COMPLETION=true AGENT_CLI_HIDE_USER_MESSAGES=true AGENT_CLI_HIDE_HEADER=true AGENT_CLI_HIDE_BANNER=true command agent --model auto --resume $CURSOR_AGENT_CHAT_ID "$prompt_text" <"$TTY" >"$TTY" 2>&1; }\n    local agent_st=$?\n\n    # Move the cursor up by one row\n    print -n "\\x1b[1A"\n\n    # Redraw a clean prompt\n    CURSOR=0\n    BUFFER=""\n    zle -R -c\n    zle reset-prompt\n    return $agent_st\n  else\n    # Normal accept-line behavior\n    zle .orig-accept-line\n  fi\n}\n\n# Create the widget and bind it\nzle -N please-fix-or-accept-line\n\n# Bind Enter key to the integrated handler\nbindkey \'^M\' please-fix-or-accept-line\n\nfi # End TTY check\n';function a(e){if("zsh"!==e)throw new Error(`Unsupported shell: ${e}`);process.stdout.write(o)}}};